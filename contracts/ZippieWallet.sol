pragma solidity ^0.5.0;

import "./ZippieMultisig.sol";
import "./ZippieCard.sol";
import "./ZippieUtils.sol";

import "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol";

/**
    @title Zippie Multisig Wallet
    @author Zippie
    @notice Handles interactions with Zippie multisig wallets
    @dev NOTE: YOUR SIGNING APPLICATION MAY NOT PREPEND "\x19Ethereum Signed Message:\n32" TO THE OBJECT TO BE SIGNED. 
    FEEL FREE TO REMOVE IF NECESSARY
 */
contract ZippieWallet is ZippieMultisig, ZippieCard {

    mapping (address => uint256) public accountLimits;

    constructor(address zippieCardNonces) ZippieCard(zippieCardNonces) public {}
    
    /** @notice Redeems a check after verifying all required signers/cards (recipient specified when check was created) 
        @dev Upon successful verification of the signatures, it's necessary to verify that the signers signed keccak256(recipient, amount, nonce)
        @param addresses multisig address, erc20 contract address, recipient
        [0] multisig account to withdraw ERC20 tokens from
        [1] ERC20 contract to use
        [2] recipient of the ERC20 tokens
        [3] verification key (nonce)
      * @param signers signers followed by card signers
      * @param m the amount of signatures required to transfer from the multisig account
        [0] possible number of signers
        [1] required number of signers
        [2] possible number of card signers
        [3] reqiuired number of card signers
      * @param v v values of all signatures
        [0] multisig account signature
        [1] verification key signature
        [2..i] signer signatures of check
        [i+1..j] card signatures of random card nonces
      * @param r r values of all signatures (structured as v)
      * @param s s values of all signatures (structured as v)
      * @param amount amount to transfer
      * @param cardNonces random values generated by cards at every read
      */
    function redeemCheck(address[] memory addresses, address[] memory signers, uint8[] memory m, uint8[] memory v, bytes32[] memory r, bytes32[] memory s, uint256 amount, bytes32[] memory cardNonces) public {
        require(addresses.length == 4, "Incorrect number of addresses");
        require(amount > 0, "Amount must be greater than 0");

        // sanity check of signature parameters 
        bool limitExceeded = isLimitExceeded(amount, addresses[0]);
        checkSignatureParameters(m, signers.length, v.length, r.length, s.length, cardNonces.length, limitExceeded);
        
        // verify that account signature is valid
        verifyMultisigAccountSignature(signers, m, addresses[0], v[0], r[0], s[0]);

        // verify nonce for replay protection (verification key signing recipient address)
        bytes32 recipientHash = ZippieUtils.toEthSignedMessageHash(keccak256(abi.encodePacked(addresses[2])));
        verifyMultisigNonce(addresses[0], addresses[3], recipientHash, v[1], r[1], s[1]);

        // get the check hash (amount, recipient, nonce) and verify that required number of signers signed it (recipient specified when check was created) 
        bytes32 checkHash = ZippieUtils.toEthSignedMessageHash(keccak256(abi.encodePacked(amount, addresses[2], addresses[3])));
        verifySignerSignatures(checkHash, [0, m[0]], signers, [2, m[1]], v, r, s);

        // need to verify that requied number of card signatures has been provided if limit is exceeded (2FA)
        if (limitExceeded) {
            // verify that card nonces are valid and has not been used already
            verifyCardSignatures(cardNonces, [m[0], m[2]], signers, [2+m[1], m[3]], v, r, s);
        }

        // transfer tokens
        require(IERC20(addresses[1]).transferFrom(addresses[0], addresses[2], amount), "Transfer failed");
    }

    /** @notice Redeems a blank check after verifying all required signers/cards (recipient specified when check was claimed) 
        @dev Upon successful verification of the signatures, it's necessary to verify that the signers signed keccak256(amount, verification key)
      * @param addresses multisig address, erc20 contract address, recipient, verification key
        [0] multisig account to withdraw ERC20 tokens from
        [1] ERC20 contract to use
        [2] recipient of the ERC20 tokens
        [3] verification key (nonce)
      * @param signers signers followed by card signers
      * @param m the amount of signatures required to transfer from the multisig account
        [0] possible number of signers
        [1] required number of signers
        [2] possible number of card signers
        [3] reqiuired number of card signers
      * @param v v values of all signatures
        [0] multisig account signature
        [1] verification key signature
        [2..i] signer signatures of check
        [i+1..j] card signatures of random card nonces
      * @param r r values of all signatures (structured as v)
      * @param s s values of all signatures (structured as v)
      * @param amount amount to transfer
      * @param cardNonces random values generated by cards at every read
      */
    function redeemBlankCheck(address[] memory addresses, address[] memory signers, uint8[] memory m, uint8[] memory v, bytes32[] memory r, bytes32[] memory s, uint256 amount, bytes32[] memory cardNonces) public {
        require(addresses.length == 4, "Incorrect number of addresses"); 
        require(amount > 0, "Amount must be greater than 0");
       
        // sanity check of signature parameters 
        bool limitExceeded = isLimitExceeded(amount, addresses[0]);
        checkSignatureParameters(m, signers.length, v.length, r.length, s.length, cardNonces.length, limitExceeded);
        
        // verify that account signature is valid
        verifyMultisigAccountSignature(signers, m, addresses[0], v[0], r[0], s[0]);

        // verify nonce for replay protection (verification key signing recipient address)
        bytes32 recipientHash = ZippieUtils.toEthSignedMessageHash(keccak256(abi.encodePacked(addresses[2])));
        verifyMultisigNonce(addresses[0], addresses[3], recipientHash, v[1], r[1], s[1]);

        // get the check hash (amount, nonce) and verify that required number of signers signed it (recipient specified when check was claimed)
        bytes32 blankCheckHash = ZippieUtils.toEthSignedMessageHash(keccak256(abi.encodePacked(amount, addresses[3])));
        verifySignerSignatures(blankCheckHash, [0, m[0]], signers, [2, m[1]], v, r, s);

        // need to verify that requied number of card signatures has been provided if limit is exceeded (2FA)
        if (limitExceeded) {
            // verify that card nonces are valid and has not been used already
            verifyCardSignatures(cardNonces, [m[0], m[2]], signers, [2+m[1], m[3]], v, r, s);
        }

        // transfer tokens
        require(IERC20(addresses[1]).transferFrom(addresses[0], addresses[2], amount), "Transfer failed");
    }

    /** @notice Set new card limit (2FA) after verifying all required signers/cards
        @dev Upon successful verification of the signatures, it's necessary to verify that the signers signed keccak256(recipient, amount, nonce)
        @param addresses multisig address, erc20 contract address, recipient
        [0] multisig account to withdraw ERC20 tokens from
        [1] ERC20 contract to use
        [2] recipient of the ERC20 tokens
        [3] nonce address
      * @param signers signers followed by card signers
      * @param m the amount of signatures required to transfer from the multisig account
        [0] possible number of signers
        [1] required number of signers
        [2] possible number of card signers
        [3] reqiuired number of card signers
      * @param v v values of all signatures
        [0] multisig account signature
        [1] verification key signature
        [2..i] signer signatures of check
        [i+1..j] card signatures of random card nonces
      * @param r r values of all signatures (structured as v)
      * @param s s values of all signatures (structured as v)
      * @param amount new limit amount
      * @param cardNonces random values generated by cards at every read
      */
    function setLimit(address[] memory addresses, address[] memory signers, uint8[] memory m, uint8[] memory v, bytes32[] memory r, bytes32[] memory s, uint256 amount, bytes32[] memory cardNonces) public {
        require(addresses.length == 4, "Incorrect number of addresses");
        
        // sanity check of signature parameters 
        bool limitExceeded = isLimitExceeded(amount, addresses[0]);
        checkSignatureParameters(m, signers.length, v.length, r.length, s.length, cardNonces.length, limitExceeded);
        
        // verify that account signature is valid
        verifyMultisigAccountSignature(signers, m, addresses[0], v[0], r[0], s[0]);

        // verify nonce for replay protection (nonce signing recipient address)
        bytes32 recipientHash = ZippieUtils.toEthSignedMessageHash(keccak256(abi.encodePacked(addresses[2])));
        verifyMultisigNonce(addresses[0], addresses[3], recipientHash, v[1], r[1], s[1]);

        // get the limit hash (amount, nonce) and verify that required number of signers signed it
        // TODO: Need to prepend function signature so hash for redeemBlankCheck don't get the same
        bytes32 limitHash = ZippieUtils.toEthSignedMessageHash(keccak256(abi.encodePacked(amount, addresses[3])));
        verifySignerSignatures(limitHash, [0, m[0]], signers, [2, m[1]], v, r, s);

        // need to verify that requied number of card signatures has been provided in order to increase the account limit (2FA)
        if (limitExceeded) {
            // verify that card nonces are valid and has not been used already
            verifyCardSignatures(cardNonces, [m[0], m[2]], signers, [2+m[1], m[3]], v, r, s);
        }

        // set limit
        accountLimits[addresses[0]] = amount;
    }

    function checkSignatureParameters(uint8[] memory m, uint256 nrOfSigners, uint256 nrOfVs, uint256 nrOfRs, uint256 nrOfSs, uint256 nrOfCardNonces, bool amountLimitExceeded) private pure {
        require(m.length == 4, "Invalid m[]"); 
        require(m[1] <= m[0], "Required number of signers cannot be higher than number of possible signers");
        require(m[3] <= m[2], "Required number of cards cannot be higher than number of possible cards");
        require(m[0] > 0, "Required number of signers cannot be 0");           
        require(m[1] > 0, "Possible number of signers cannot be 0");  
        require(m[0] != 0xFF, "Required number of signers cannot be MAX UINT8"); 
        require(m[1] != 0xFF, "Possible number of signers cannot be MAX UINT8"); 
        require(m[2] != 0xFF, "Required number of cards cannot be MAX UINT8"); 
        require(m[3] != 0xFF, "Possible number of cards cannot be MAX UINT8"); 
        
        if (amountLimitExceeded) {
            require(nrOfSigners == m[0] + m[2], "Incorrect number of signers"); 
            require(nrOfVs == 2 + m[1] + m[3], "Incorrect number of signatures (v)"); 
            require(nrOfRs == 2 + m[1] + m[3], "Incorrect number of signatures (r)"); 
            require(nrOfSs == 2 + m[1] + m[3], "Incorrect number of signatures (s)"); 
            require(nrOfCardNonces == m[3], "Incorrect number of card nonces"); 
        } else {
            // Accept either card signatures appended or missing (even if not required since amount is below limit)
            require(nrOfSigners == m[0] || nrOfSigners == m[0] + m[2], "Incorrect number of signers"); 
            require(nrOfVs == 2 + m[1] || nrOfVs == 2 + m[1] + m[3], "Incorrect number of signatures (v)"); 
            require(nrOfRs == 2 + m[1] || nrOfRs == 2 + m[1] + m[3], "Incorrect number of signatures (r)"); 
            require(nrOfSs == 2 + m[1] || nrOfSs == 2 + m[1] + m[3], "Incorrect number of signatures (s)"); 
            require(nrOfCardNonces == 0 || nrOfCardNonces == m[3], "Incorrect number of card nonces"); 
        }
    }

    function isLimitExceeded(uint256 amount, address account) private view returns(bool){
        return amount > accountLimits[account];
    }
}