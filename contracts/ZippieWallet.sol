pragma solidity ^0.4.24;

import "./ZippieMultisig.sol";
import "./ZippieNonce.sol";
import "./ZippieCard.sol";
import "./ZippieUtils.sol";

import "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol";

/**
    @title Zippie Multisig Wallet
    @author Zippie
    @notice Handles interactions with Zippie multisig wallets
    @dev NOTE: YOUR SIGNING APPLICATION MAY NOT PREPEND "\x19Ethereum Signed Message:\n32" TO THE OBJECT TO BE SIGNED. 
    FEEL FREE TO REMOVE IF NECESSARY
 */
contract ZippieWallet is ZippieMultisig, ZippieNonce, ZippieCard {

    mapping (address => uint256) public accountLimits;

    constructor(address zippieCardNonces) ZippieCard(zippieCardNonces) public {}
    /** @notice Redeems a check after verifying all required signers/cards
        @dev Upon successful verification of the signatures, it's necessary to verify that the signers signed keccak256(recipient, amount, nonce)
        @param addresses multisig address, erc20 contract address, recipient
        [0] multisig account to withdraw ERC20 tokens from
        [1] ERC20 contract to use
        [2] recipient of the ERC20 tokens
        [3] nonce
      * @param signers signers followed by card signers
      * @param m the amount of signatures required to transfer from the multisig account
        [0] number of signers
        [1] minimum number of signers
        [2] number of card signers
        [3] minimum number of card signers
      * @param v v values of all signatures
        [0] multisig account signature
        [1] verification key signature
        [2..i] signer signatures of check
        [i+1..j] card signatures of random card nonces
      * @param r r values of all signatures (structured as v)
      * @param s s values of all signatures (structured as v)
      * @param amount amount to transfer
      * @param cardNonces random values generated by cards at every read
      */
    function redeemCheck(address[] addresses, address[] signers, uint8[] m, uint8[] v, bytes32[] r, bytes32[] s, uint256 amount, bytes32[] cardNonces) public {
        bool limitExceeded = isLimitExceeded(amount, addresses[0]);
        verifyMultisigParameters(addresses.length, signers.length, m, v.length, r.length, s.length, cardNonces.length, limitExceeded);
        verifyMultisigAccountSignature(signers, m, addresses[0], v[0], r[0], s[0]);

        require(amount > 0, "Amount must be greater than 0");

        // verify nonce
        verifyMultisigNonce(addresses[0], addresses[3], addresses[2], v[1], r[1], s[1]);

        // get the check hash (amount, recipient, nonce) to verify signer signatures
        // verify that the signers signed that they want to transfer "amount" ERC20 token
        bytes32 checkHash = ZippieUtils.toEthSignedMessageHash(keccak256(abi.encodePacked(amount, addresses[2], addresses[3])));
        verifySignerSignatures(checkHash, 2, m, signers, v, r, s);

        // need to verify card signatures if limit is exceeded
        if (limitExceeded) {
            verifyCardSignatures(cardNonces, 2, m, signers, v, r, s);
        }

        // transfer tokens
        require(IERC20(addresses[1]).transferFrom(addresses[0], addresses[2], amount), "Transfer failed");
    }

    /** @notice Redeems a blank check after verifying all required signers/cards
        @dev Upon successful verification of the signatures, it's necessary to verify that the signers signed keccak256(amount, verification key)
      * @param addresses multisig address, erc20 contract address, recipient, verification key
        [0] multisig account to withdraw ERC20 tokens from
        [1] ERC20 contract to use
        [2] recipient of the ERC20 tokens
        [3] nonce
      * @param signers signers followed by card signers
      * @param m the amount of signatures required to transfer from the multisig account
        [0] number of signers
        [1] minimum number of signers
        [2] number of card signers
        [3] minimum number of card signers
      * @param v v values of all signatures
        [0] multisig account signature
        [1] verification key signature
        [2..i] signer signatures of check
        [i+1..j] card signatures of random card nonces
      * @param r r values of all signatures (structured as v)
      * @param s s values of all signatures (structured as v)
      * @param amount amount to transfer
      * @param cardNonces random values generated by cards at every read
      */
    function redeemBlankCheck(address[] addresses, address[] signers, uint8[] m, uint8[] v, bytes32[] r, bytes32[] s, uint256 amount, bytes32[] cardNonces) public {
        bool limitExceeded = isLimitExceeded(amount, addresses[0]);
        verifyMultisigParameters(addresses.length, signers.length, m, v.length, r.length, s.length, cardNonces.length, limitExceeded);
        verifyMultisigAccountSignature(signers, m, addresses[0], v[0], r[0], s[0]);

        require(amount > 0, "Amount must be greater than 0");

        // verify nonce
        verifyMultisigNonce(addresses[0], addresses[3], addresses[2], v[1], r[1], s[1]);

        // get the blank check hash (amount, verification key) to verify signer signatures
        // verify that the signers signed that they want to transfer "amount" ERC20 token
        bytes32 blankCheckHash = ZippieUtils.toEthSignedMessageHash(keccak256(abi.encodePacked(amount, addresses[3])));
        verifySignerSignatures(blankCheckHash, 2, m, signers, v, r, s);

        // need to verify card signatures if limit is exceeded
        if (limitExceeded) {
            verifyCardSignatures(cardNonces, 2, m, signers, v, r, s);
        }

        // transfer tokens
        require(IERC20(addresses[1]).transferFrom(addresses[0], addresses[2], amount), "Transfer failed");
    }

    function setLimit(address[] addresses, address[] signers, uint8[] m, uint8[] v, bytes32[] r, bytes32[] s, uint256 amount, bytes32[] cardNonces) public {
        bool limitExceeded = isLimitExceeded(amount, addresses[0]);
        verifyMultisigParameters(addresses.length, signers.length, m, v.length, r.length, s.length, cardNonces.length, limitExceeded);
        verifyMultisigAccountSignature(signers, m, addresses[0], v[0], r[0], s[0]);

        // verify nonce
        verifyMultisigNonce(addresses[0], addresses[3], addresses[2], v[1], r[1], s[1]);

        // get the limit hash (amount, verification key) to verify signer signatures
        // verify that m signers signed that they want to set limit to ammount
        // TODO: Need to prepend function signature so hash for redeemBlankCheck don't get the same
        bytes32 limitHash = ZippieUtils.toEthSignedMessageHash(keccak256(abi.encodePacked(amount, addresses[3])));
        verifySignerSignatures(limitHash, 2, m, signers, v, r, s);

        // need to verify card signatures to increase account limit
        if (limitExceeded) {
            verifyCardSignatures(cardNonces, 2, m, signers, v, r, s);
        }

        // set limit
        accountLimits[addresses[0]] = amount;
    }

    function verifyMultisigParameters(uint256 nrOfAddresses, uint256 nrOfSigners, uint8[] m, uint256 nrOfVs, uint256 nrOfRs, uint256 nrOfSs, uint256 nrOfCardNonces, bool amountLimitExceeded) private pure {
        require(m.length == 4, "Invalid m[]"); 
        require(m[1] <= m[0], "Required number of signers cannot be higher than number of possible signers");
        require(m[3] <= m[2], "Required number of cards cannot be higher than number of possible cards");
        require(m[0] > 0, "Required number of signers cannot be 0");           
        require(m[1] > 0, "Possible number of signers cannot be 0");  
        // TODO: Do we need this if we use SafeMath?
        require(m[0] != 0xFF, "Cannot be MAX UINT8"); 
        require(m[1] != 0xFF, "Cannot be MAX UINT8"); 
        require(m[2] != 0xFF, "Cannot be MAX UINT8"); 
        require(m[3] != 0xFF, "Cannot be MAX UINT8"); 
        require(nrOfAddresses == 2 + 1 + 1, "Incorrect number of addresses"); 
        
        if (amountLimitExceeded) {
            require(nrOfSigners == m[0] + m[2], "Incorrect number of signers"); 
            require(nrOfVs == 2 + m[1] + m[3], "Incorrect number of signatures (v)"); 
            require(nrOfRs == 2 + m[1] + m[3], "Incorrect number of signatures (r)"); 
            require(nrOfSs == 2 + m[1] + m[3], "Incorrect number of signatures (s)"); 
            require(nrOfCardNonces == m[3], "Incorrect number of card nonces"); 
        } else {
            // Accept either card signatures appended or missing (even if not required since amount is below limit)
            require(nrOfSigners == m[0] || nrOfSigners == m[0] + m[2], "Incorrect number of signers"); 
            require(nrOfVs == 2 + m[1] || nrOfVs == 2 + m[1] + m[3], "Incorrect number of signatures (v)"); 
            require(nrOfRs == 2 + m[1] || nrOfRs == 2 + m[1] + m[3], "Incorrect number of signatures (r)"); 
            require(nrOfSs == 2 + m[1] || nrOfSs == 2 + m[1] + m[3], "Incorrect number of signatures (s)"); 
            require(nrOfCardNonces == 0 || nrOfCardNonces == m[3], "Incorrect number of card nonces"); 
        }
    }

    function isLimitExceeded(uint256 amount, address account) private view returns(bool){
        return amount > accountLimits[account];
    }
}