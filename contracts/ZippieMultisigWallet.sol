pragma solidity 0.4.24;

import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";

contract ZippieMultisigWallet{

    // this is needed to prevent someone from reusing signatures to create unwanted transactions and drain a multsig
    mapping (address => uint256) addressNonceMapping;
    mapping (address => mapping(address => bool)) public checkCashed;

    // address[] addresses 
    // -- [0] multisig address to withdraw from
    // -- [1] erc20 contract address to use
    // -- [2] recipient (recipient of the ERC20 tokens upon successful verification of the signatures, note that we must verify that the signers signed keccak256 recipient, amount, nonce)
    // address[] allSignersPossible -- signers followed by card signers (the temporary private key will keccak256 this array and m, to allow m of allSignersPossible.length = n signatures in that array to transfer from the wallet)
    // uint256[] m -- nrOfSigners, minNrOfSigners, nrOfCardSigners, minNrOfCardSigners (the amount of signatures required to transfer from the multisig wallet)
    // uint256[] v -- X, signer signatures, card signatures, Z (v values of all signatures, v[0] will be the temporary private key signature, and v[1], ... v[m] will be from the multisig keys)
    // bytes32[] r -- X, signer signatures, card signatures, Z (r values of all signatures, r[0] will be from the temporary private key signature, as before...)
    // bytes32[] s -- X, signer signatures, card signatures, Z (s values of all signatures, s[0] will be temporary private key signature, as before...)
    // uint256 nonce -- the nonce of the sent, this must be the value in addressNonceMapping[address tempPrivKey] + 1;
    // uint256 amount -- amount to transfer
    // bytes32[] cardDigests -- random values generated by cards at every read
    function redeemCheck(address[] addresses, address[] allSignersPossible, uint256[] m, uint256[] v, bytes32[] r, bytes32[] s, uint256 nonce, uint256 amount, bytes32[] cardDigests) public {

        // require that m, allSignersPossible are well formed (m <= allSignersPossible.length, m not zero, and m not MAX_UINT8)
        // require that v/r/s.length are equal to (m + the original temp private key sig)
        // require that the nonce is incremented by 1
        require(
            addresses.length == 3 && 
            m[1] + m[3] <= allSignersPossible.length && 
            m[1] <= m[0] && 
            m[3] <= m[2] && 
            m[1] > 0 && 
            m[1] < 256 && 
            m[3] < 256 && 
            r.length == m[1] + m[3] + 1 && 
            s.length == m[1] + m[3] + 1 && 
            v.length == m[1] + m[3] + 1 && 
            cardDigests.length == m[3] && 
            nonce == addressNonceMapping[addresses[0]] + 1
        );

        // verify that the multisig wallet previously signed that these keys can access the funds
        require(verifyMultisigKeyAllowsAddresses(allSignersPossible, m, addresses[0], v[0], r[0], s[0]));

        // verify that all the other signatures were addresses in allSignersPossible, 
        // that they all signed keccak256(amount, receiver, nonce), 
        // and that there are no duplicate signatures/addresses

        // get the new hash to verify
        bytes32 hashVerify = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(abi.encodePacked(amount, addresses[2], nonce))));

        // make a memory mapping of (addresses => used this address?) to check for duplicates
        address[] memory usedAddresses = new address[](m[1] + m[3]);

        // loop through and ec_recover each v[] r[] s[] and verify that a correct address came out, and it wasn't a duplicate
        address addressVerify;

        for (uint256 i = 1; i < m[1] + m[3] + 1; i++) {

            if (i > m[1]) {
                // verify card digests
                hashVerify = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", cardDigests[i-m[0]-1]));
            }

            // get address from ec_recover
            addressVerify = ecrecover(hashVerify, uint8(v[i]), r[i], s[i]);

            // check that address is a valid address 
            require(checkIfAddressInArray(allSignersPossible, addressVerify));

            // check that this address has not been used before
            require(!checkIfAddressInArray(usedAddresses, addressVerify));

            // if we've made it here, we have verified that the first signature is a valid signature of a legal account,
            // it isn't a duplicate signature,
            // and that the signature signed that he/she wants to transfer "amount" ERC20 token to "receiver"

            // push this address to the usedAddresses array
            usedAddresses[i - 1] = addressVerify;
        }

        // if we've made it here, past the guantlet of asserts(), then we have verified that these are all signatures of legal addresses
        // and that they all want to transfer "amount" tokens to "receiver"

        // now all there is left to do is transfer these tokens!
        ERC20(addresses[1]).transferFrom(addresses[0], addresses[2], amount);
            
        // increment the nonce
        addressNonceMapping[addresses[0]] = nonce;
    }

    // addresses -- multisig address, erc20 contract address, recipient, verification key
    // -- [0..2] as above
    // -- [3] verification key
    
    function redeemBlankCheck(address[] addresses, address[] allSignersPossible, uint256[] m, uint256[] v, bytes32[] r, bytes32[] s, uint256 amount, bytes32[] cardDigests) public {

        require(
            addresses.length == 4 && 
            m[1] + m[3] <= allSignersPossible.length && 
            m[1] <= m[0] && 
            m[3] <= m[2] && 
            m[1] > 0 && 
            m[1] != 0xFF && 
            r.length == m[1] + m[3] + 2 && 
            s.length == m[1] + m[3] + 2 && 
            v.length == m[1] + m[3] + 2 && 
            cardDigests.length == m[3] && 
            !checkCashed[addresses[0]][addresses[3]]
        );

        // verify that the multisig wallet previously signed that these keys can access the funds
        require(verifyMultisigKeyAllowsAddresses(allSignersPossible, m, addresses[0], v[0], r[0], s[0]));

        // verify that all the other signatures were addresses in allSignersPossible, 
        // that they all signed keccak256(amount, verificationKey),
        // and that there are no duplicate signatures/addresses

        // get the new hash to verify
        bytes32 hashVerify = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(abi.encodePacked(amount, addresses[3]))));

        // make a memory mapping of (addresses => used this address?) to check for duplicates
        address[] memory usedAddresses = new address[](m[1] + m[3]);

        // loop through and ec_recover each v[] r[] s[] and verify that a correct address came out, and it wasn't a duplicate
        address addressVerify;

        for (uint256 i = 1; i < m[1] + m[3] + 1; i++) {

            if (i > m[1]) {
                // verify card digests
                hashVerify = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", cardDigests[i-m[0]-1]));
            }

            // get address from ec_recover
            addressVerify = ecrecover(hashVerify, uint8(v[i]), r[i], s[i]);

            // check that address is a valid address 
            require(checkIfAddressInArray(allSignersPossible, addressVerify));

            // check that this address has not been used before
            require(!checkIfAddressInArray(usedAddresses, addressVerify));

            // if we've made it here, we have verified that the first signature is a valid signature of a legal account,
            // it isn't a duplicate signature,
            // and that the signature signed that he/she wants to transfer "amount" ERC20 token to any chosen "receiver" by the user that has knowledge of 
            // the private verification key to cash the check 

            // push this address to the usedAddresses array
            usedAddresses[i - 1] = addressVerify;
        }

        // now verify the last element in the arrays is the verification key signing the recipient address
        hashVerify = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(abi.encodePacked(addresses[2]))));

        // note that i == m + 1, or the last element in r,s,v
        addressVerify = ecrecover(hashVerify, uint8(v[i]), r[i], s[i]);

        require(addressVerify == addresses[3]);

        // if we've made it here, past the guantlet of asserts(), then we have verified that these are all signatures of legal addresses
        // and that they all want to transfer "amount" tokens to any chosen "receiver" by the user that has knowledge of 
        // the private verification key to cash the check 

        // now all there is left to do is transfer these tokens!
        ERC20(addresses[1]).transferFrom(addresses[0], addresses[2], amount);
            
        // add to the checkCashed array to so that this check can't be cashed again.
        checkCashed[addresses[0]][addresses[3]] = true;
    }


    // a simple helper function to check if an address is in an array...
    function checkIfAddressInArray(address[] validAddresses, address checkAddress) internal pure returns(bool){

        // loop through all addresses in array
        for (uint i = 0; i < validAddresses.length; i++){
            if (checkAddress == validAddresses[i]){ 
                return true;
            }
        }
        return false;
    }

    // helper function to verify that the multisig wallet (temp priv key) signed to allow this array of 
    // addresses to access the wallet funds.
    function verifyMultisigKeyAllowsAddresses(address[] signers, uint256[] m, address multisigAddress, uint256 v, bytes32 r, bytes32 s) internal pure returns(bool successfulVerification){
        // NOTE: YOUR SIGNING APPLICATION MAY NOT PREPEND "\x19Ethereum Signed Message:\n32" TO THE OBJECT TO BE SIGNED. 
        // FEEL FREE TO REMOVE IF NECESSARY
        // verify that the tempPrivKey signed the initial signature of hash keccak256(allSignersPossible, m)
        // perform the ec_recover on this hash with the first v, r, s values
        // return true if the multisig address signed this hash, else return false
        return multisigAddress == ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(abi.encodePacked(signers, m)))), uint8(v), r, s);
    }

    // these functions are simply for testing
    // since truffle/web3 hashes things in a different way, we can call these pure functions
    // and hash things inside the evm so we can be sure that things will hash the same
    function soliditySha3_addresses_m(address[] validAddresses, uint256[] m) public pure returns(bytes32){
        return keccak256(abi.encodePacked(validAddresses, m));
    }

    function soliditySha3_amount_recipient_nonce(uint256 amount, address recipient, uint256 nonce) public pure returns(bytes32){
        return keccak256(abi.encodePacked(amount, recipient, nonce));
    }

    function soliditySha3_amount_address(uint256 amount, address key) public pure returns(bytes32){
        return keccak256(abi.encodePacked(amount, key));
    }

    function soliditySha3_address(address addr) public pure returns(bytes32){
        return keccak256(abi.encodePacked(addr));
    }

    function soliditySha3_sign(bytes32 hash) public pure returns(bytes32){
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }
}