pragma solidity ^0.4.24;

import "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol";

/**
    @title Zippie Multisig Wallet
    @author Zippie
    @notice Handles interactions with Zippie multisig wallets
    @dev NOTE: YOUR SIGNING APPLICATION MAY NOT PREPEND "\x19Ethereum Signed Message:\n32" TO THE OBJECT TO BE SIGNED. 
    FEEL FREE TO REMOVE IF NECESSARY
 */
contract ZippieMultisigWallet {

    // this is needed to prevent someone from reusing signatures to create unwanted transactions (replay protection)
    mapping (address => mapping(address => bool)) public usedNonces;
    mapping (address => mapping(bytes32 => bool)) public usedCardNonces;
    mapping (address => uint256) public accountLimits;

    /** @notice Redeems a check after verifying all required signers/cards
        @dev Upon successful verification of the signatures, it's necessary to verify that the signers signed keccak256(recipient, amount, nonce)
        @param addresses multisig address, erc20 contract address, recipient
        [0] multisig account to withdraw ERC20 tokens from
        [1] ERC20 contract to use
        [2] recipient of the ERC20 tokens
        [3] nonce
      * @param signers signers followed by card signers
      * @param m the amount of signatures required to transfer from the multisig account
        [0] number of signers
        [1] minimum number of signers
        [2] number of card signers
        [3] minimum number of card signers
      * @param v v values of all signatures
        [0] multisig account signature
        [1] verification key signature
        [2..i] signer signatures of check
        [i+1..j] card signatures of random card nonces
      * @param r r values of all signatures (structured as v)
      * @param s s values of all signatures (structured as v)
      * @param amount amount to transfer
      * @param cardNonces random values generated by cards at every read
      */
    function redeemCheck(address[] addresses, address[] signers, uint8[] m, uint8[] v, bytes32[] r, bytes32[] s, uint256 amount, bytes32[] cardNonces) public {
        verifyData(addresses, signers, m, v, r, s, amount, cardNonces);

        // get the check hash (amount, recipient, nonce) to verify signer signatures
        bytes32 checkHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(abi.encodePacked(amount, addresses[2], addresses[3]))));
        // need to check card signatures if account limit is exceeded
        bool limitExceeded = amount > accountLimits[addresses[0]];
        // verify that the signers signed that they want to transfer "amount" ERC20 tokens and verify card signatures
        verifySignatures(checkHash, signers, m, v, r, s, cardNonces, limitExceeded);

        // transfer tokens
        require(IERC20(addresses[1]).transferFrom(addresses[0], addresses[2], amount), "Transfer failed");
    }

    /** @notice Redeems a blank check after verifying all required signers/cards
        @dev Upon successful verification of the signatures, it's necessary to verify that the signers signed keccak256(amount, verification key)
      * @param addresses multisig address, erc20 contract address, recipient, verification key
        [0] multisig account to withdraw ERC20 tokens from
        [1] ERC20 contract to use
        [2] recipient of the ERC20 tokens
        [3] nonce
      * @param signers signers followed by card signers
      * @param m the amount of signatures required to transfer from the multisig account
        [0] number of signers
        [1] minimum number of signers
        [2] number of card signers
        [3] minimum number of card signers
      * @param v v values of all signatures
        [0] multisig account signature
        [1] verification key signature
        [2..i] signer signatures of check
        [i+1..j] card signatures of random card nonces
      * @param r r values of all signatures (structured as v)
      * @param s s values of all signatures (structured as v)
      * @param amount amount to transfer
      * @param cardNonces random values generated by cards at every read
      */
    function redeemBlankCheck(address[] addresses, address[] signers, uint8[] m, uint8[] v, bytes32[] r, bytes32[] s, uint256 amount, bytes32[] cardNonces) public {
        verifyData(addresses, signers, m, v, r, s, amount, cardNonces);
        require(amount > 0, "Amount must be greater than 0");
        
        // need to check card signatures if account limit is exceeded
        bool limitExceeded = amount > accountLimits[addresses[0]];

        // get the blank check hash (amount, verification key) to verify signer signatures
        bytes32 blankCheckHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(abi.encodePacked(amount, addresses[3]))));
        // verify that the signers signed that they want to transfer "amount" ERC20 token and verify card signatures (unless below limit)
        verifySignatures(blankCheckHash, signers, m, v, r, s, cardNonces, limitExceeded);

        // transfer tokens
        require(IERC20(addresses[1]).transferFrom(addresses[0], addresses[2], amount), "Transfer failed");
    }

    function setLimit(address[] addresses, address[] signers, uint8[] m, uint8[] v, bytes32[] r, bytes32[] s, uint256 amount, bytes32[] cardNonces) public {
        verifyData(addresses, signers, m, v, r, s, amount, cardNonces);

        // get the limit hash (amount, verification key) to verify signer signatures
        bytes32 limitHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(abi.encodePacked(amount, addresses[3]))));
        // verify that the signers signed that they want to transfer "amount" ERC20 token and verify card signatures
        verifySignatures(limitHash, signers, m, v, r, s, cardNonces, true);

        // set limit
        accountLimits[addresses[0]] = amount;
    }

    function verifyData(address[] addresses, address[] signers, uint8[] m, uint8[] v, bytes32[] r, bytes32[] s, uint256 amount, bytes32[] cardNonces) internal {
        require(addresses.length == 4, "Incorrect address input");
        // require(amount > 0, "Amount must be greater than 0");
        // require(verifySignatureRequirements(m, signers.length, v, r, s, cardNonces.length), "Invalid signature input");
        // verify that the verification key signed the recipient address
        require(verifyMultisigNonce(addresses[0], addresses[3], addresses[2], v[1], r[1], s[1]),  "Invalid nonce");
        require(verifyMultisigAccountSignature(signers, m, addresses[0], v[0], r[0], s[0]), "Invalid account");
    }

    /** @dev Verify that all signatures were addresses in signers, 
            that they all signed keccak256(amount, verificationKey) or keccak256(amount, receiver, nonce) (for cards)
            and that there are no duplicate signatures/addresses
     */
    function verifySignatures(bytes32 signedHash, address[] signers, uint8[] m, uint8[] v, bytes32[] r, bytes32[] s, bytes32[] cardNonces, bool checkCardSignatures) internal {
        require(verifySignatureRequirements(m, signers.length, v, r, s, cardNonces.length, checkCardSignatures), "Invalid signature input");

        // make a memory mapping of (addresses => used this address?) to check for duplicates
        address[] memory usedAddresses = new address[](m[1] + m[3]);

        // loop through and ec_recover each v[] r[] s[] and verify that a correct address came out, and it wasn't a duplicate
        address addressToVerify;

        for (uint8 i = 2; i < m[1] + m[3] + 2; i++) {

            if (i > m[1] + 1) {
                if (checkCardSignatures == false) {
                    return;
                }
                // verify card nonces
                bytes32 signedNonce = cardNonces[i - m[0] - 2];
                require(usedCardNonces[signers[i - 2]][signedNonce] == false, "Card nonce reused");
                // store the card nonce to prevent future reuse
                usedCardNonces[signers[i - 2]][signedNonce] = true;
                addressToVerify = ecrecover(signedNonce, v[i], r[i], s[i]);
            } else {
                // get address from ec_recover
                addressToVerify = ecrecover(signedHash, v[i], r[i], s[i]);
            }

            // check that address is a valid address 
            require(isAddressInArray(signers, addressToVerify), "Invalid address found when verifying signatures");

            // check that this address has not been used before
            require(!isAddressInArray(usedAddresses, addressToVerify), "Address has been used already");

            // push this address to the usedAddresses array
            usedAddresses[i - 2] = addressToVerify;
        }
    }

    function isAddressInArray(address[] validAddresses, address checkAddress) internal pure returns(bool) {
        for (uint i = 0; i < validAddresses.length; i++) {
            if (checkAddress == validAddresses[i]) {
                return true;
            }
        }
        
        return false;
    }

    /** @dev verify that the multisig account (temp priv key) signed to allow this array of addresses to access the account's funds.
        the temporary private key will keccak256 this array and m, to allow m of signers.length = n signatures in that array to transfer from the wallet
        @return true if the multisig address signed this hash, else false 
     */
    function verifyMultisigAccountSignature(address[] signers, uint8[] m, address multisigAddress, uint8 v, bytes32 r, bytes32 s) internal pure returns(bool successfulVerification) {
        return multisigAddress == ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(abi.encodePacked(signers, m)))), v, r, s);
    }

    function verifySignatureRequirements(uint8[] m, uint256 nrOfSigners, uint8[] v, bytes32[] r, bytes32[] s, uint256 nrOfCards, bool checkCardSignatures) internal pure returns(bool successfulVerification) {
        uint8 minNrOfCards = 0;
        if (checkCardSignatures) {
            minNrOfCards = m[3];
        }

        return
            // require that m, signers are well formed (m <= nrOfSigners, m not zero, and m not MAX_UINT8)
            m[0] + m[2] == nrOfSigners &&
            m[1] + m[3] <= nrOfSigners && 
            m[1] <= m[0] && 
            m[3] <= m[2] && 
            m[1] > 0 && 
            m[1] != 0xFF &&
            // require that v/r/s.length are equal to (the original temp private key sig and the verification key + m)
            r.length == 2 + m[1] + minNrOfCards && 
            s.length == 2 + m[1] + minNrOfCards && 
            v.length == 2 + m[1] + minNrOfCards &&
            nrOfCards == minNrOfCards;
    }

    function verifyMultisigNonce(address multisigAddress, address nonceAddress, address addressSignedByNonce, uint8 v, bytes32 r, bytes32 s) internal returns(bool successfulVerification) {
        if (nonceAddress == ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(abi.encodePacked(addressSignedByNonce)))), v, r, s) &&
            !usedNonces[multisigAddress][nonceAddress]) {
            // flag nonce to prevent reuse
            usedNonces[multisigAddress][nonceAddress] = true;   
            return true;
        }
        return false;
    }
}