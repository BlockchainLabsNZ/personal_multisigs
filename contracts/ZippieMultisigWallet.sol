pragma solidity 0.4.24;

import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";

contract ZippieMultisigWallet{

    // this is needed to prevent someone from reusing signatures to create unwanted transactions and drain a multsig
    mapping (address => uint256) addressNonceMapping;
    mapping (address => mapping(address => bool)) public checkCashed;
    mapping (address => mapping(bytes32 => bool)) public cardNonces;

    // address[] addresses 
    // -- [0] multisig address to withdraw from
    // -- [1] erc20 contract address to use
    // -- [2] recipient (recipient of the ERC20 tokens upon successful verification of the signatures, note that we must verify that the signers signed keccak256 recipient, amount, nonce)
    // address[] allSignersPossible -- signers followed by card signers (the temporary private key will keccak256 this array and m, to allow m of allSignersPossible.length = n signatures in that array to transfer from the wallet)
    // uint8[] m -- nrOfSigners, minNrOfSigners, nrOfCardSigners, minNrOfCardSigners (the amount of signatures required to transfer from the multisig wallet)
    // uint8[] v -- X, signer signatures, card signatures, Z (v values of all signatures, v[0] will be the temporary private key signature, and v[1], ... v[m] will be from the multisig keys)
    // bytes32[] r -- X, signer signatures, card signatures, Z (r values of all signatures, r[0] will be from the temporary private key signature, as before...)
    // bytes32[] s -- X, signer signatures, card signatures, Z (s values of all signatures, s[0] will be temporary private key signature, as before...)
    // uint256 nonce -- the nonce of the sent, this must be the value in addressNonceMapping[address tempPrivKey] + 1;
    // uint256 amount -- amount to transfer
    // bytes32[] cardDigests -- random values generated by cards at every read
    function redeemCheck(address[] addresses, address[] allSignersPossible, uint8[] m, uint8[] v, bytes32[] r, bytes32[] s, uint256 nonce, uint256 amount, bytes32[] cardDigests) public {

        require(verifySignatureRequirements(m, allSignersPossible.length, v, r, s, 1, cardDigests.length), "Invalid check signatures");
        require(isValidCheck(addresses, nonce),  "Invalid check");

        // verify that the multisig wallet previously signed that these keys can access the funds
        require(verifyMultisigKeyAllowsAddresses(allSignersPossible, m, addresses[0], v[0], r[0], s[0]), "Invalid address");

        // if we've made it here, we have verified that the first signature is a valid signature of a legal account

        // verify that all the other signatures were addresses in allSignersPossible, 
        // that they all signed keccak256(amount, receiver, nonce), 
        // and that there are no duplicate signatures/addresses

        // get the new hash to verify
        bytes32 hashVerify = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(abi.encodePacked(amount, addresses[2], nonce))));

        verifySignatures(hashVerify, allSignersPossible, m, v, r, s, cardDigests);

        // if we've made it here, past the guantlet of asserts(), then we have verified that these are all signatures of legal addresses
        // and that they all want to transfer "amount" tokens to "receiver"

        // now all there is left to do is transfer these tokens!
        ERC20(addresses[1]).transferFrom(addresses[0], addresses[2], amount);
            
        // increment the nonce
        addressNonceMapping[addresses[0]] = nonce;
    }

    // addresses -- multisig address, erc20 contract address, recipient, verification key
    // -- [0..2] as above
    // -- [3] verification key
    function redeemBlankCheck(address[] addresses, address[] allSignersPossible, uint8[] m, uint8[] v, bytes32[] r, bytes32[] s, uint256 amount, bytes32[] cardDigests) public {
        require(verifySignatureRequirements(m, allSignersPossible.length, v, r, s, 2, cardDigests.length), "Invalid blank check signatures");
        require(isValidBlankCheck(addresses),  "Invalid blank check");

        // verify that the multisig wallet previously signed that these keys can access the funds
        require(verifyMultisigKeyAllowsAddresses(allSignersPossible, m, addresses[0], v[0], r[0], s[0]), "Invalid address");

        // if we've made it here, we have verified that the first signature is a valid signature of a legal account

        // verify that all the other signatures were addresses in allSignersPossible, 
        // that they all signed keccak256(amount, verificationKey),
        // and that there are no duplicate signatures/addresses

        // get the new hash to verify
        bytes32 hashVerify = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(abi.encodePacked(amount, addresses[3]))));

        verifySignatures(hashVerify, allSignersPossible, m, v, r, s, cardDigests);

        // if we've made it here, we have verified that the signature signed that he/she wants to transfer "amount" ERC20 token to any chosen "receiver" by the user that has knowledge of 
        // the private verification key to cash the check 

        // now verify the last element in the arrays is the verification key signing the recipient address
        hashVerify = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(abi.encodePacked(addresses[2]))));

        // note that i == m + 1, or the last element in r,s,v
        address addressVerify = ecrecover(hashVerify, v[s.length - 1], r[s.length - 1], s[s.length - 1]);

        require(addressVerify == addresses[3], "Incorrect address");

        // if we've made it here, past the guantlet of asserts(), then we have verified that these are all signatures of legal addresses
        // and that they all want to transfer "amount" tokens to any chosen "receiver" by the user that has knowledge of 
        // the private verification key to cash the check 
        // add to the checkCashed array to so that this check can't be cashed again.
        checkCashed[addresses[0]][addresses[3]] = true;

        // now all there is left to do is transfer these tokens!
        require(ERC20(addresses[1]).transferFrom(addresses[0], addresses[2], amount), "Transfer failed");
    }

    function verifySignatures(bytes32 hashVerify, address[] allSignersPossible, uint8[] m, uint8[] v, bytes32[] r, bytes32[] s, bytes32[] cardDigests) internal {
        // make a memory mapping of (addresses => used this address?) to check for duplicates
        address[] memory usedAddresses = new address[](m[1] + m[3]);

        // loop through and ec_recover each v[] r[] s[] and verify that a correct address came out, and it wasn't a duplicate
        address addressVerify;

        for (uint8 i = 1; i < m[1] + m[3] + 1; i++) {

            if (i > m[1]) {
                // verify card digests
                bytes32 digest = cardDigests[i - m[0] - 1];
                hashVerify = digest;
                require(cardNonces[allSignersPossible[i - 1]][digest] == false, "Card nonce reused");
                // store the card digest to prevent future reuse
                cardNonces[allSignersPossible[i - 1]][digest] = true;
            }

            // get address from ec_recover
            addressVerify = ecrecover(hashVerify, v[i], r[i], s[i]);

            // check that address is a valid address 
            require(checkIfAddressInArray(allSignersPossible, addressVerify), "Invalid address found when verifying signatures");

            // check that this address has not been used before
            require(!checkIfAddressInArray(usedAddresses, addressVerify), "Address has been used already");

            // push this address to the usedAddresses array
            usedAddresses[i - 1] = addressVerify;
        }
    }

    // a simple helper function to check if an address is in an array...
    function checkIfAddressInArray(address[] validAddresses, address checkAddress) internal pure returns(bool){

        // loop through all addresses in array
        for (uint i = 0; i < validAddresses.length; i++){
            if (checkAddress == validAddresses[i]){ 
                return true;
            }
        }
        
        return false;
    }

    // helper function to verify that the multisig wallet (temp priv key) signed to allow this array of 
    // addresses to access the wallet funds.
    function verifyMultisigKeyAllowsAddresses(address[] signers, uint8[] m, address multisigAddress, uint8 v, bytes32 r, bytes32 s) internal pure returns(bool successfulVerification){
        // NOTE: YOUR SIGNING APPLICATION MAY NOT PREPEND "\x19Ethereum Signed Message:\n32" TO THE OBJECT TO BE SIGNED. 
        // FEEL FREE TO REMOVE IF NECESSARY
        // verify that the tempPrivKey signed the initial signature of hash keccak256(allSignersPossible, m)
        // perform the ec_recover on this hash with the first v, r, s values
        // return true if the multisig address signed this hash, else return false
        return multisigAddress == ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(abi.encodePacked(signers, m)))), v, r, s);
    }

    function verifySignatureRequirements(uint8[] m, uint256 nrOfSigners, uint8[] v, bytes32[] r, bytes32[] s, uint256 offset, uint256 nrOfCards) internal pure returns(bool successfulVerification) {
        return 
            // require that m, allSignersPossible are well formed (m <= nrOfSigners, m not zero, and m not MAX_UINT8)
            m[0] + m[2] == nrOfSigners && 
            m[1] + m[3] <= nrOfSigners && 
            m[1] <= m[0] && 
            m[3] <= m[2] && 
            m[1] > 0 && 
            m[1] != 0xFF &&
            // require that v/r/s.length are equal to (m + the original temp private key sig and/or the verification key)
            r.length == m[1] + m[3] + offset && 
            s.length == m[1] + m[3] + offset && 
            v.length == m[1] + m[3] + offset &&
            nrOfCards == m[3];
    }

    function isValidCheck(address[] addresses, uint256 nonce) internal view returns(bool successfulVerification) {
        return 
            addresses.length == 3 &&
            // verify nonce is incremented by 1
            nonce == addressNonceMapping[addresses[0]] + 1;
    }

    function isValidBlankCheck(address[] addresses) internal view returns(bool successfulVerification) {
        return 
            addresses.length == 4 && 
            !checkCashed[addresses[0]][addresses[3]];
    }
}